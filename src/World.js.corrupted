import Utils from './Utils.js';
import Enemy from './Enemy.js';
import Meteor from './Meteor.js';
import Boss from './Boss.js';

export default class World {
    constructor(game) {
        this.game = game;
        this.enemies = [];
        this.projectiles = [];
        this.particles = [];
        this.meteors = [];
        this.boss = null;
        this.bossSpawned = false;
        this.bossLevel = 1;
        this.nextBossScore = 10000; // First boss at 10000

        this.bgOffset = 0;
        this.enemyTimer = 0;
        this.enemyInterval = 1500;
        this.meteorTimer = 0;
        this.meteorInterval = 2000;
        this.speed = 5; // World scrolling speed

        // Background Elements
        this.stars = [];
        this.planets = [];
        this.nebulae = [];
        this.initBackground();
        this.planetTimer = 0;
    }

    initBackground() {
        // Create 3 layers of stars
        for (let i = 0; i < 300; i++) {
            this.stars.push({
                x: Math.random() * this.game.width,
                y: Math.random() * this.game.height,
                size: Math.random() * 2 + 0.5,
                speed: Math.random() * 2 + 0.5, // Parallax speed factor
                brightness: Math.random() * 0.5 // Reduced brightness (max 0.5)
            });
        }

        // Create Nebulae (Distant background clouds)
        this.nebulae = [];
        for (let i = 0; i < 5; i++) {
            this.nebulae.push({
                x: Math.random() * this.game.width,
                y: Math.random() * this.game.height,
                radius: Utils.random(200, 400),
                color: `hsla(${Utils.random(220, 320)}, 60%, 50%, 0.1)` // Blue/Purple/Pink
            });
        }
    }

    update(deltaTime) {
        // Update Background (Stars)
        this.stars.forEach(star => {
            star.x -= (this.speed * star.speed * 0.1) * (deltaTime / 16);
            if (star.x < 0) {
                star.x = this.game.width;
                star.y = Math.random() * this.game.height;
            }
        });

        // Update Planets
        this.planetTimer += deltaTime;

        // Emergency Fuel Spawn
        const hasFuelPlanet = this.planets.some(p => p.type === 'FUEL');
        // Spawn if fuel < 30% AND no fuel planet exists AND timer > 1s (almost immediate)
        if (this.game.player.fuel < 30 && !hasFuelPlanet && this.planetTimer > 1000) {
            this.spawnPlanet(true);
            this.planetTimer = 0;
        }

        if (this.planetTimer > 10000) { // Spawn planet every 10s
            this.spawnPlanet();
            this.planetTimer = 0;
        }

        this.planets.forEach((planet, index) => {
            planet.x -= (this.speed * planet.speed) * (deltaTime / 16);
            if (planet.x + planet.radius < 0) {
                this.planets.splice(index, 1);
            }

            // Check for Power-up Collection
            if (planet.type !== 'NONE') {
                const dx = this.game.player.x - planet.x;
                const dy = this.game.player.y - planet.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < planet.radius + this.game.player.width) {
                    // Collect Power-up
                    // Boss Logic
                    if (!this.bossSpawned && this.game.score >= this.nextBossScore) {
                        this.boss = new Boss(this.game, this.bossLevel);
                        this.bossSpawned = true;

                        // Clear existing enemies when boss appears
                        this.enemies.forEach(e => e.markedForDeletion = true);

                        // Play Boss Music
                        this.game.audio.playBossMusic();
                    }

                    if (this.boss) {
                        this.boss.update(deltaTime);
                        if (this.boss.health <= 0) {
                            this.createExplosion(this.boss.x + this.boss.width / 2, this.boss.y + this.boss.height / 2, 100, '#ff0000');
                            this.boss = null;
                            this.bossSpawned = false;
                            this.game.score += 5000 * this.bossLevel;

                            // Prepare for next boss
                            this.bossLevel++;
                            this.nextBossScore += 3000; // Next boss in 3000 points

                            // Increase game difficulty
                            this.speed += 1;
                            this.enemyInterval = Math.max(200, this.enemyInterval - 100);

                            // Celebration Effect
                            this.createCelebration(this.boss.x + this.boss.width / 2, this.boss.y + this.boss.height / 2);

                            // Return to normal music
                            this.game.audio.playMusic();
                        }
                    } else {
                        // Spawn Enemies only if no boss
                        this.enemyTimer += deltaTime;
                        if (this.enemyTimer > this.enemyInterval) {
                            this.spawnEnemy();
                            this.enemyTimer = 0;
                            if (this.enemyInterval > 500) this.enemyInterval -= 20;
                            this.speed += 0.005; // Slowly increase game speed
                        }

                        // Spawn Meteors
                        this.meteorTimer += deltaTime;
                        if (this.meteorTimer > this.meteorInterval) {
                            this.meteors.push(new Meteor(this.game));
                            this.meteorTimer = 0;
                            this.meteorInterval = Utils.random(1000, 3000);
                        }
                    }

                    // Update Enemies
                    for (let i = this.enemies.length - 1; i >= 0; i--) {
                        const enemy = this.enemies[i];
                        enemy.update(deltaTime);
                        if (enemy.markedForDeletion) {
                            this.enemies.splice(i, 1);
                        }
                    }

                    // Update Meteors
                    for (let i = this.meteors.length - 1; i >= 0; i--) {
                        const meteor = this.meteors[i];
                        meteor.update(deltaTime);
                        if (meteor.markedForDeletion) {
                            this.meteors.splice(i, 1);
                            continue;
                        }

                        // Check Player Collision
                        const playerBounds = this.game.player.getBounds();
                        playerBounds.x += 10; playerBounds.width -= 20;
                        playerBounds.y += 10; playerBounds.height -= 20;

                        const meteorBounds = {
                            x: meteor.x - meteor.radius * 0.8,
                            y: meteor.y - meteor.radius * 0.8,
                            width: meteor.radius * 1.6,
                            height: meteor.radius * 1.6
                        };

                        if (Utils.checkCollision({ x: meteorBounds.x, y: meteorBounds.y, width: meteorBounds.width, height: meteorBounds.height }, playerBounds)) {
                            meteor.markedForDeletion = true;
                            this.createExplosion(meteor.x, meteor.y, 30, '#ff8800');
                            this.game.audio.playExplosionSound();

                            // Full invincibility during shield OR respawn
                            if (!this.game.player.shieldActive && !this.game.player.isRespawning) {
                                this.game.player.loseLife();
                            }
                        }
                    }

                    // Update Projectiles
                    for (let i = this.projectiles.length - 1; i >= 0; i--) {
                        const p = this.projectiles[i];
                        p.update(deltaTime);
                        if (p.x > this.game.width || p.x < 0 || p.y > this.game.height || p.y < 0) {
                            p.markedForDeletion = true;
                        }

                        if (p.markedForDeletion) {
                            this.projectiles.splice(i, 1);
                            continue;
                        }
                    }

                    // Projectile vs Projectile collision (player shots vs enemy shots)
                    for (let i = this.projectiles.length - 1; i >= 0; i--) {
                        const p1 = this.projectiles[i];
                        if (p1.markedForDeletion || p1.type === 'ENEMY') continue; // Only check player projectiles

                        for (let j = this.projectiles.length - 1; j >= 0; j--) {
                            const p2 = this.projectiles[j];
                            if (i === j || p2.markedForDeletion || p2.type !== 'ENEMY') continue; // Only against enemy projectiles

                            // Simple AABB collision
                            if (Utils.checkCollision(p1, p2)) {
                                p1.markedForDeletion = true;
                                p2.markedForDeletion = true;
                                this.createExplosion(p1.x, p1.y, 3, '#ffaa00'); // Small explosion
                                break; // Exit inner loop since p1 is destroyed
                            }
                        }
                    }

                    // Check collisions (after projectile vs projectile)
                    for (let i = this.projectiles.length - 1; i >= 0; i--) {
                        const p = this.projectiles[i];
                        if (p.markedForDeletion) continue;
                        if (p.type === 'ENEMY') {
                            // Enemy projectile vs Player
                            const playerBounds = this.game.player.getBounds();
                            playerBounds.x += 10; playerBounds.width -= 20;
                            playerBounds.y += 5; playerBounds.height -= 10;

                            if (Utils.checkCollision(p, playerBounds)) {
                                p.markedForDeletion = true;
                                this.createExplosion(p.x, p.y, 5, p.color);

                                // Full invincibility during shield OR respawn
                                if (!this.game.player.shieldActive && !this.game.player.isRespawning) {
                                    this.game.player.loseLife();
                                }
                            }
                        } else {
                            // Player projectile vs Enemies
                            for (let j = this.enemies.length - 1; j >= 0; j--) {
                                const enemy = this.enemies[j];
                                if (Utils.checkCollision(p, enemy)) {
                                    enemy.health -= p.damage;
                                    p.markedForDeletion = true;
                                    this.createExplosion(p.x, p.y, 5, p.color);

                                    if (enemy.health <= 0) {
                                        enemy.markedForDeletion = true;
                                        this.game.score += enemy.scoreValue;
                                        this.game.audio.playExplosionSound();
                                        this.createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, 20, enemy.color);
                                        if (Math.random() > 0.9) this.game.player.weaponLevel = Math.min(this.game.player.weaponLevel + 1, 3);
                                    }
                                    break;
                                }
                            }

                            // Player projectile vs Boss
                            if (this.boss) {
                                if (this.boss.checkCollision(p)) {
                                    p.markedForDeletion = true;
                                }
                            }
                        }

                        // Check collision with meteors (Player projectiles only)
                        if (p.type !== 'ENEMY') {
                            for (let k = this.meteors.length - 1; k >= 0; k--) {
                                const meteor = this.meteors[k];
                                const meteorBounds = {
                                    x: meteor.x - meteor.radius,
                                    y: meteor.y - meteor.radius,
                                    width: meteor.radius * 2,
                                    height: meteor.radius * 2
                                };

                                if (Utils.checkCollision(p, meteorBounds)) {
                                    p.markedForDeletion = true;

                                    // Damage meteor
                                    const destroyed = meteor.takeDamage(1);

                                    if (destroyed) {
                                        // Award points based on size
                                        const points = meteor.size === 'large' ? 50 : (meteor.size === 'medium' ? 30 : 20);
                                        this.game.score += points;

                                        // Create fragments
                                        const fragments = meteor.fragment();
                                        this.meteors.push(...fragments);

                                        // Big explosion
                                        this.createExplosion(meteor.x, meteor.y, 20, '#ff8800');
                                        this.game.audio.playExplosionSound();
                                    } else {
                                        // Hit but not destroyed - small impact
                                        this.createExplosion(p.x, p.y, 5, '#aaa');
                                    }

                                    break;
                                }
                            }
                        }
                    }

                    // Update particles
                    this.particles.forEach((p, index) => {
                        if (p.isFlash) {
                            p.size *= p.decay;
                            p.life -= deltaTime;
                        } else {
                            p.x += p.vx;
                            p.y += p.vy;
                            p.life -= deltaTime;
                            p.size *= (p.decay || 1);
                        }

                        if (p.life <= 0 || p.size < 0.5) this.particles.splice(index, 1);
                    });
                }

                spawnPlanet(forceFuel = false) {
                    const radius = Utils.random(50, 150);
                    const rand = Math.random();
                    let type = 'NONE';

                    if (forceFuel || this.game.player.fuel < 30) {
                        type = 'FUEL';
                    } else {
                        // Better distribution: 35% FUEL, 20% SHIELD, 25% WEAPON, 15% RAPID_FIRE, 5% NONE
                        if (rand < 0.35) {
                            type = 'FUEL';
                        } else if (rand < 0.55) {
                            type = 'SHIELD';
                        } else if (rand < 0.80) {
                            type = 'WEAPON';
                        } else if (rand < 0.95) {
                            type = 'RAPID_FIRE';
                        } else {
                            type = 'NONE';
                        }
                    }

                    this.planets.push({
                        x: this.game.width + radius,
                        y: Utils.random(radius, this.game.height - radius),
                        radius: radius,
                        color: `hsl(${Utils.random(0, 360)}, 70%, 50%)`,
                        speed: 0.5,
                        type: type,
                        hasRings: Math.random() > 0.5,
                        ringColor: `hsla(${Utils.random(0, 360)}, 40%, 60%, 0.6)`,
                        ringAngle: Utils.random(-0.5, 0.5)
                    });
                }

                spawnEnemy() {
                    this.enemies.push(new Enemy(this.game));
                }

                addProjectile(projectile) {
                    this.projectiles.push(projectile);
                }

                createCelebration(x, y) {
                    // Massive explosion
                    this.createExplosion(x, y, 200, '#ffaa00');
                    this.createExplosion(x, y, 100, '#ffffff');

                    // Fireworks
                    for (let i = 0; i < 10; i++) {
                        setTimeout(() => {
                            this.createExplosion(
                                x + Utils.random(-200, 200),
                                y + Utils.random(-200, 200),
                                50,
                                `hsl(${Utils.random(0, 360)}, 100%, 50%)`
                            );
                            this.game.audio.playExplosionSound();
                        }, i * 200);
                    }
                }

                createExplosion(x, y, count, color) {
                    for (let i = 0; i < count * 2; i++) {
                        this.particles.push({
                            x: x,
                            y: y,
                            vx: Utils.random(-8, 8),
                            vy: Utils.random(-8, 8),
                            life: Utils.random(300, 800),
                            color: color,
                            size: Utils.random(3, 8),
                            decay: 0.95
                        });
                    }

                    for (let i = 0; i < count; i++) {
                        this.particles.push({
                            x: x,
                            y: y,
                            vx: Utils.random(-4, 4),
                            vy: Utils.random(-4, 4),
                            life: Utils.random(500, 1000),
                            color: Math.random() > 0.5 ? '#ffaa00' : '#888888',
                            size: Utils.random(5, 12),
                            decay: 0.98
                        });
                    }

                    this.particles.push({
                        x: x,
                        y: y,
                        vx: 0,
                        vy: 0,
                        life: 200,
                        color: '#ffffff',
                        size: 50,
                        decay: 0.8,
                        isFlash: true
                    });
                }

                draw(ctx) {
                    this.drawBackground(ctx);
                    this.meteors.forEach(meteor => meteor.draw(ctx));
                    this.enemies.forEach(enemy => enemy.draw(ctx));
                    if (this.boss) this.boss.draw(ctx);
                    this.projectiles.forEach(p => p.draw(ctx));
                    this.particles.forEach(p => {
                        ctx.fillStyle = p.color;
                        ctx.globalAlpha = p.life / 500;
                        ctx.fillRect(p.x, p.y, p.size, p.size);
                        ctx.globalAlpha = 1;
                    });
                }

                drawBackground(ctx) {
                    this.nebulae.forEach(nebula => {
                        const gradient = ctx.createRadialGradient(nebula.x, nebula.y, 0, nebula.x, nebula.y, nebula.radius);
                        gradient.addColorStop(0, nebula.color);
                        gradient.addColorStop(1, 'transparent');
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(nebula.x, nebula.y, nebula.radius, 0, Math.PI * 2);
                        ctx.fill();
                    });

                    ctx.fillStyle = '#ffffff';
                    this.stars.forEach(star => {
                        ctx.globalAlpha = star.brightness;
                        ctx.beginPath();
                        ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    ctx.globalAlpha = 1;

                    this.planets.forEach(planet => {
                        ctx.save();
                        ctx.translate(planet.x, planet.y);

                        // Draw Rings (Back)
                        if (planet.hasRings) {
                            ctx.save();
                            ctx.rotate(planet.ringAngle);
                            ctx.scale(1, 0.3);
                            ctx.beginPath();
                            ctx.arc(0, 0, planet.radius * 2.2, 0, Math.PI * 2);
                            ctx.strokeStyle = planet.ringColor;
                            ctx.lineWidth = 20;
                            ctx.stroke();
                            ctx.restore();
                        }

                        // Planet Body
                        const gradient = ctx.createRadialGradient(-planet.radius / 3, -planet.radius / 3, planet.radius / 10, 0, 0, planet.radius);
                        gradient.addColorStop(0, planet.color);
                        gradient.addColorStop(1, '#000000');

                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(0, 0, planet.radius, 0, Math.PI * 2);
                        ctx.fill();

                        // Power-up Indicator
                        if (planet.type !== 'NONE') {
                            if (planet.type === 'WEAPON') {
                                ctx.fillStyle = '#fff';
                                ctx.font = '20px Arial';
                                ctx.textAlign = 'center';
                                ctx.fillText('‚öîÔ∏è', 0, 0);
                            } else if (planet.type === 'SHIELD') {
                                ctx.fillStyle = '#fff';
                                ctx.font = '20px Arial';
                                ctx.textAlign = 'center';
                                ctx.fillText('üõ°Ô∏è', 0, 0);
                            } else if (planet.type === 'FUEL') {
                                // Gas Effect
                                const time = Date.now() / 500;
                                const gasRadius = planet.radius * 1.5;

                                // Create multiple gas layers
                                for (let i = 0; i < 3; i++) {
                                    const offset = i * (Math.PI * 2 / 3);
                                    const scale = 1 + Math.sin(time + offset) * 0.1;

                                    const gradient = ctx.createRadialGradient(0, 0, planet.radius * 0.5, 0, 0, gasRadius * scale);
                                    gradient.addColorStop(0, 'rgba(0, 255, 100, 0.2)'); // Greenish gas core
                                    gradient.addColorStop(0.5, 'rgba(100, 255, 0, 0.1)');
                                    gradient.addColorStop(1, 'transparent');

                                    ctx.fillStyle = gradient;
                                    ctx.beginPath();
                                    ctx.arc(0, 0, gasRadius * scale, 0, Math.PI * 2);
                                    ctx.fill();
                                }

                                // Floating particles
                                ctx.fillStyle = 'rgba(50, 255, 50, 0.6)';
                                for (let i = 0; i < 5; i++) {
                                    const angle = (time * 2 + i) % (Math.PI * 2);
                                    const dist = planet.radius + Math.sin(time * 3 + i) * 10;
                                    ctx.beginPath();
                                    ctx.arc(Math.cos(angle) * dist, Math.sin(angle) * dist, 3, 0, Math.PI * 2);
                                    ctx.fill();
                                }
                            }

                            // Pulsing glow for all powerups
                            ctx.strokeStyle = '#fff';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.arc(0, 0, planet.radius + 10 + Math.sin(Date.now() / 200) * 5, 0, Math.PI * 2);
                            ctx.stroke();
                        }

                        // Draw Rings (Front)
                        if (planet.hasRings) {
                            ctx.save();
                            ctx.rotate(planet.ringAngle);
                            ctx.scale(1, 0.3);
                            ctx.beginPath();
                            ctx.arc(0, 0, planet.radius * 2.2, 0, Math.PI, true); // Bottom half only? No, full arc but masked? 
                            // Simple approach: Draw front part of ring
                            ctx.beginPath();
                            ctx.arc(0, 0, planet.radius * 2.2, 0, Math.PI * 2);
                            // Actually, to make it look like it goes behind, we need to split it.
                            // For now, let's just draw it on top, it looks okay for 2D arcade.
                            // Or better: Draw back half before planet, front half after.
                            // Since we are here, let's just re-draw the FRONT half.
                            ctx.beginPath();
                            ctx.arc(0, 0, planet.radius * 2.2, 0, Math.PI, false);
                            ctx.strokeStyle = planet.ringColor;
                            ctx.lineWidth = 20;
                            ctx.stroke();
                            ctx.restore();
                        }

                        ctx.restore();
                    });
                }

                reset() {
                    this.enemies = [];
                    this.projectiles = [];
                    this.particles = [];
                    this.planets = [];
                    this.meteors = [];
                    this.boss = null;
                    this.bossSpawned = false;
                    this.bossLevel = 1;
                    this.nextBossScore = 10000;
                    this.speed = 5;
                    this.enemyInterval = 1500;
                    this.initBackground();

                    // Reset music
                    this.game.audio.playMusic();
                }
            }
